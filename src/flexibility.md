# 灵活性

## 函数公开中间结果以避免重复工作 (C-INTERMEDIATE)

许多函数在回答问题时也会计算相关数据。如果这些数据对用户可能有用，考虑在 API 中公开它们。

### 标准库中的示例

- [`Vec::binary_search`] 不返回一个表示值是否找到的 `bool`，也不返回一个表示值可能找到的索引的 `Option<usize>`。相反，它返回有关索引的信息，如果未找到，还会返回需要插入值的索引。

- [`String::from_utf8`] 如果输入字节不是 UTF-8 可能会失败。在错误情况下，它返回一个中间结果，暴露输入中有效 UTF-8 的字节偏移量，并返回输入字节的所有权。

- [`HashMap::insert`] 返回一个 `Option<T>`，其中包含给定键的预先存在的值（如果有）。对于用户想要恢复此值的情况，通过插入操作返回它可以避免用户进行第二次哈希表查找。

## 调用者决定数据的复制和放置位置 (C-CALLER-CONTROL)

如果函数需要参数的所有权，它应该获取参数的所有权，而不是借用和克隆参数。

```rust
// 优先选择这样：
fn foo(b: Bar) {
    /* 直接使用 b 作为所有权 */
}

// 而不是这样：
fn foo(b: &Bar) {
    let b = b.clone();
    /* 克隆后使用 b 作为所有权 */
}
```

如果函数*不需要*参数的所有权，它应该借用参数而不是获取所有权并在函数返回前丢弃参数。

```rust
// 优先选择这样：
fn foo(b: &Bar) {
    /* 使用 b 作为借用 */
}

// 而不是这样：
fn foo(b: Bar) {
    /* 使用 b 作为借用，函数返回前会隐式丢弃 b */
}
```

`Copy` 特性应仅在绝对需要时使用，而不是用来表示复制应该是廉价的。

## 函数通过使用泛型最小化对参数的假设 (C-GENERIC)

函数对输入的假设越少，其适用范围就越广。

优先选择

```rust
fn foo<I: IntoIterator<Item = i64>>(iter: I) { /* ... */ }
```

而不是

```rust
fn foo(c: &[i64]) { /* ... */ }
fn foo(c: &Vec<i64>) { /* ... */ }
fn foo(c: &SomeOtherCollection<i64>) { /* ... */ }
```

如果函数只需要迭代数据。

### 泛型的优点

- _可重用性_：泛型函数可以应用于开放集合的类型，同时提供这些类型必须提供的功能的明确约定。
- _静态调度和优化_：每次使用泛型函数时，都会针对实现特性边界的特定类型进行专门化，从而使特性方法的调用是静态的、直接的，并且编译器可以内联和优化这些调用。
- _内联布局_：如果 `struct` 和 `enum` 类型是某个类型参数 `T` 的泛型，`T` 类型的值将在 `struct`/`enum` 中内联布局，没有任何间接。
- _推断_：由于泛型函数的类型参数通常可以被推断，泛型函数可以帮助减少代码中的冗长。
- _精确类型_：因为泛型为实现特性的特定类型提供了一个_名称_，所以可以精确地表达需要或产生该精确类型的地方。

### 泛型的缺点

- _代码大小_：专用化泛型函数意味着函数体被复制。代码大小的增加必须与静态调度的性能收益权衡。
- _同质类型_：这是“精确类型”的另一面：如果 `T` 是一个类型参数，它代表一个_单一_的实际类型。因此，例如，`Vec<T>` 包含单一具体类型的元素（实际上，向量表示被专门化以将这些元素内联布局）。有时异构集合是有用的；参见[特征对象][C-OBJECT]。
- _签名冗长_：泛型使用过多可能会使函数签名更难以阅读和理解。

### 标准库中的示例

- [`std::fs::File::open`] 接受泛型类型 `AsRef<Path>` 的参数。这允许从字符串字面量 `"f.txt"`、[`Path`]、[`OsString`] 和其他一些类型方便地打开文件。

## 如果特征作为特征对象有用，则应是对象安全的 (C-OBJECT)

特征对象有一些显著的限制：通过特征对象调用的方法不能使用泛型，且不能在接收者位置之外使用 `Self`。

在设计特征时，尽早决定特征是作为对象使用还是作为泛型边界使用。

如果特征旨在用作对象，其方法应接受和返回特征对象而不是使用泛型。

`where Self: Sized` 子句可用于从特征对象中排除特定方法。以下特征由于泛型方法而不是对象安全的。

```rust
trait MyTrait {
    fn object_safe(&self, i: i32);

    fn not_object_safe<T>(&self, t: T);
}
```

向泛型方法添加 `Self: Sized` 的要求可以将其从特征对象中排除，并使特征对象安全。

```rust
trait MyTrait {
    fn object_safe(&self, i: i32);

    fn not_object_safe<T>(&self, t: T) where Self: Sized;
}
```

### 特征对象的优点

- _异构性_：当你需要它时，你真的需要它。
- _代码大小_：与泛型不同，特征对象不生成专用化（单态化）版本的代码，这可以大大减少代码大小。

### 特征对象的缺点

- _无泛型方法_：特征对象目前不能提供泛型方法。
- _动态调度和胖指针_：特征对象本质上涉及间接和 vtable 调度，这可能带来性能损失。
- _无 Self_：除了方法接收者参数外，特征对象上的方法不能使用 `Self` 类型。

### 标准库中的示例

- [`io::Read`] 和 [`io::Write`] 特征经常用作对象。
- [`Iterator`] 特征有几个带有 `where Self: Sized` 标记的泛型方法，以保留将 `Iterator` 用作对象的能力。